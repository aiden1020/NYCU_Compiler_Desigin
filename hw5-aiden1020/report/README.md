# hw5 report

|||
|-:|:-|
|Name|黃梓濤|
|ID|313552001|

## How much time did you spend on this project

> e.g. 2 hours.

Total about 20 hours.
More specifically, 2 hours were spent reading the README file and reviewing the basic concepts of code generation and assembly language, 17 hours were spent on coding, and 1 hour on writing this report.
## Project overview

> Please describe the structure of your code and the ideas behind your implementation in an organized way.
> The point is to show us how you deal with the problems. It is not necessary to write a lot of words or paste all of your code here.

### Overview

In this assignment, RISC-V assembly code is to be generated by traversing the abstract syntax tree (AST) and symbol table. Global and local declarations are to be translated into appropriate directives. Arithmetic and logical expressions, assignments, input/output operations (print, read), and control flow constructs (if/else, for, while) are to be converted into stack-based instructions. Function calls and returns are to be handled using a push/pop stack model with a fixed 128-byte stack frame. The resulting assembly code is to be emitted as a .S file named after the input .p source file.

This implementation focuses on the **code generation phase** of a compiler for the P language, emitting **RISC-V assembly** based on AST traversal. The main class is `CodeGenerator`, which implements the **visitor pattern** to walk through different types of AST nodes and emit corresponding assembly code using `dumpInstructions()`.

### **Key Design Components**

#### 1. **File Setup and Output**

* `CodeGenerator` constructor sets up the `.S` output file based on the input source path.
* Assembly emission is centralized using the `dumpInstructions()` helper for formatting.

#### 2. **Symbol Table and Scope Management**

* Each node type with an associated scope (`ProgramNode`, `FunctionNode`, `CompoundStatementNode`, `ForNode`) pushes its symbol table using `m_symbol_manager.pushScope(...)` and pops it after processing.
* Variables are located and offset using `SymbolEntry`, enabling both global and local access.

#### 3. **Stack-Based Evaluation Model**

* A **stack machine model** is used for expression evaluation:

  * Values are pushed to the stack.
  * Operations pop operands and push results.
  * L-values push addresses for assignments.

#### 4. **Function Handling**

* Functions use a **128-byte fixed stack frame** with prologue/epilogue macros.
* Parameters are loaded from registers `a0–a7` or `t2+` if overflowing.
* Return values are placed in `a0`.

#### 5. **Control Flow Implementation**

* **If, While, and For** nodes use unique labels (`L%d`) for branching.
* Conditional branches use comparisons followed by jumps to labeled sections.

## What is the hardest you think in this project

> Not required, but bonus point may be given.

One of the most difficult parts of this project is managing labels and jumps for control flow structures such as if, while, and for. Since each conditional or loop requires unique labels to represent different execution paths (e.g., body, else, exit), careful coordination is needed to generate correct and non-conflicting label IDs. It becomes even more complex when dealing with nested or sequential control structures, where jumps must target the right label and preserve execution order. A small mistake in label assignment or jump generation can lead to incorrect flow or infinite loops, making this part especially error-prone and tricky to debug.

## Feedback to T.A.s

> Not required, but bonus point may be given.

* The assignment is well-structured and builds up language features progressively, which helps in managing complexity.
* The provided codebase was clean and easy to follow .
* The debugging process taught me a lot about the behavior of code generation and assembly language implementation
* It would be helpful if the assignment provided the sample RISC-V assembly code for each test case.
